##### Outdoor Sensor Station #####

esphome:
  project:
    name: "outdoor.sensor_station"
    version: "1.0.0"
  name: sensor-station
  friendly_name: Sensor Station
  area: outside
  on_boot:
    then:
      - logger.log: "Booting, powering sensors"
      # Enable sensor power rail
      - switch.turn_on: pms_power
      - delay: 5s # Let sensors stabilize
      # Conditionally enable PMS
      - script.execute: maybe_enable_pms
      # Delay only if PMS is active
      - if:
          condition:
            lambda: "return id(pms_power).state;"
          then:
            - logger.log: "Delaying for PMS warm-up (30s)"
            - delay: 30s
      # Smart sleep logic
      - script.execute: smart_sleep

esp32:
  board: esp32-c3-devkitm-1 # Closest board profile for ESP32-C3 SuperMini
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Sensor-Station Fallback Hotspot"
    password: "z0FUaCP6k1gQ"

captive_portal:

# Enable logging for troubleshooting
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

# Enable OTA updates
ota:
  - platform: esphome
    password: !secret ota_password

# Set deep sleep mode for power efficiency
deep_sleep:
  id: deep_sleep_control
  run_duration: 45s # default run duration
  sleep_duration: 5min # default sleep duration (can be overridden dynamically)

# I2C bus configuration (GPIO4=SDA, GPIO5=SCL)
i2c:
  sda: GPIO4
  scl: GPIO5
  scan: true

# Configure sensors
sensor:
  # ADC for TEMT6000 ambient light sensor
  - platform: adc
    pin: GPIO0
    name: "Ambient Light"
    id: ambient_light
    update_interval: 5s

  # AHT20 temperature and humidity sensor
  - platform: aht10
    temperature:
      name: "Ambient Temperature"
      id: ambient_temp
    humidity:
      name: "Ambient Humidity"
      id: ambient_humidity
    update_interval: 5s

  # BMP280 atmospheric pressure sensor
  - platform: bmp280_i2c
    temperature:
      name: "BMP280 Temperature" # Secondary temp reading
      id: bmp280_temp
    pressure:
      name: "Atmospheric Pressure"
      id: atmospheric_pressure
    address: 0x76 # Verify sensor address
    update_interval: 5s

  # TMP102 internal enclosure temperature sensor
  - platform: tmp102
    name: "Enclosure Internal Temp"
    id: enclosure_temp
    address: 0x48 # Verify sensor address
    update_interval: 5s

  # DS18B20 pond water temperature sensor
  - platform: dallas_temp
    address: 0x1234567812345628 # Replace with real sensor address
    name: "Pond Water Temperature"
    id: pond_temp
    update_interval: 5s

  # INA219 voltage/current sensors
  # Solar Power Supply
  - platform: ina219
    address: 0x40
    shunt_resistance: 0.1 ohm
    current:
      name: "Solar Current"
      id: solar_current
    power:
      name: "Solar Power"
      id: solar_power
    bus_voltage:
      name: "Solar Voltage"
      id: solar_voltage
    update_interval: 5s

    # Battery Power Supply/Charging
  - platform: ina219
    address: 0x41
    shunt_resistance: 0.1 ohm
    current:
      name: "Battery Current"
      id: batt_current
    bus_voltage:
      name: Battery Voltage
      id: batt_voltage
    power:
      name: "Battery Power"
      id: batt_power
    update_interval: 5s

  # PMS5003 Particulate Matter Sensor
  - platform: pmsx003
    type: PMSX003
    pm_1_0:
      name: "PM1.0"
      id: pm_1_0
    pm_2_5:
      name: "PM2.5"
      id: pm_2_5
    pm_10_0:
      name: "PM10.0"
      id: pm_10_0
    update_interval: 30s
    id: pms_sensor

  # HC-SR04 Ultrasonic Distance sensor
  - platform: ultrasonic
    trigger_pin: GPIO10
    echo_pin: GPIO3
    name: "Water Level Distance"
    id: water_distance
    update_interval: 5s

  # Calculate actual water level
  - platform: template
    name: "Actual Water Level"
    id: pond_level
    lambda: |-
      const float sensor_height = 100.0;  // Set this to the distance from the sensor to water level at zero (in cm)
      return sensor_height - id(water_distance).state;
    unit_of_measurement: "cm"
    update_interval: 5s

    # Template to calculate battery charge percentage
  - platform: template
    name: "Battery Percentage"
    id: batt_percent
    unit_of_measurement: "%"
    device_class: battery
    update_interval: 5s
    accuracy_decimals: 0
    lambda: |-
      float v = id(batt_voltage).state;
      if (v >= 4.2) return 100;
      if (v <= 3.2) return 0;
      return (v - 3.2) * 100.0 / (4.2 - 3.2);

  # Template to calculate System Power
  - platform: template
    name: "Estimated Total Power Use"
    id: total_power_use
    unit_of_measurement: "W"
    accuracy_decimals: 2
    update_interval: 5s
    lambda: |-
      return (id(solar_voltage).state * id(solar_current).state) -
             (id(batt_voltage).state * id(batt_current).state);

  # Daily total energy usage (resets every day)
  - platform: total_daily_energy
    name: "Total Energy Used Today"
    id: total_energy_today
    power_id: total_power_use
    unit_of_measurement: "Wh"
    accuracy_decimals: 2
    restore: true

  # Lifetime total energy usage (never resets)
  - platform: integration
    name: "Total Energy Used (All-Time)"
    id: total_energy_all_time
    sensor: total_power_use
    time_unit: h
    unit_of_measurement: "Wh"
    accuracy_decimals: 2
    restore: true

  # Daily solar charge (resets every day)
  - platform: total_daily_energy
    name: "Solar Energy Collected Today"
    id: total_solar_today
    power_id: solar_power
    unit_of_measurement: "Wh"
    accuracy_decimals: 2
    restore: true

  # Lifetime solar charge (never resets)
  - platform: integration
    name: "Solar Energy Collected (All-Time)"
    id: total_solar_all_time
    sensor: solar_power
    time_unit: h
    unit_of_measurement: "Wh"
    accuracy_decimals: 2
    restore: true

  # WiFi signal strength/RSSI in dB
  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  # WiFi signal strength in %
  - platform: copy
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    id: wifi_signal_percent
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""

# Dallas 1-wire setup
one_wire:
  - platform: gpio
    pin: GPIO6

# UART for PMS5003 air quality sensor
uart:
  rx_pin: GPIO21
  tx_pin: GPIO20
  baud_rate: 9600

switch:
  # Virtual switch to enable wake-lock (for OTA updates)
  - platform: template
    id: wake_hold_switch
    name: "Wake-Lock"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log: "Wake-Lock ON → Preventing deep sleep."
      - deep_sleep.prevent: deep_sleep_control
    turn_off_action:
      - logger.log: "Wake-Lock OFF → Allowing deep sleep."
      - deep_sleep.allow: deep_sleep_control

    # Switch for PMS power supply
  - platform: gpio
    pin:
      number: GPIO2
      ignore_strapping_warning: true
    id: pms_power
    name: "PMS Sensor Power"

    # Heater control via GPIO8 through MOSFET
  - platform: gpio
    pin:
      number: GPIO8
      ignore_strapping_warning: true
    name: "Internal Heater"
    id: internal_heater

  # Input boolean to control smart sleep duration
  - platform: template
    id: force_long_sleep
    name: "Force Long Sleep"
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    optimistic: true

time:
  # Sleep timer
  - platform: homeassistant
    id: ha_time
    on_time:
      - seconds: 9
        minutes: "*"
        then:
          - script.execute: prepare_for_sleep
          - delay: 100ms
          - script.execute: smart_sleep
  - platform: sntp
    id: sntp_time

script:
  # Smart sleep control
  - id: smart_sleep
    then:
      - lambda: |-
          ESP_LOGI("smart_sleep", "Deciding sleep duration...");
          if (id(force_long_sleep).state) {
            ESP_LOGI("smart_sleep", "Force Long Sleep active → 30min");
            id(deep_sleep_control).set_sleep_duration(30 * 60 * 1000); // 30min
          } else {
            float battery_v = id(batt_voltage).state;
            float solar_i = id(solar_current).state;

            if (battery_v > 3.7 && solar_i > 50.0) {
              ESP_LOGI("smart_sleep", "Battery OK (%.2fV), Solar Good (%.1fmA) → Short Sleep (5min)", battery_v, solar_i);
              id(deep_sleep_control).set_sleep_duration(5 * 60 * 1000); // 5min
            } else {
              ESP_LOGI("smart_sleep", "Battery Low (%.2fV) or Solar Weak (%.1fmA) → Long Sleep (30min)", battery_v, solar_i);
              id(deep_sleep_control).set_sleep_duration(30 * 60 * 1000); // 30min
            }
          }
      - deep_sleep.enter: deep_sleep_control

  # Deep sleep preparation
  - id: prepare_for_sleep
    mode: restart
    then:
      - logger.log: "Preparing for deep sleep"
      - output.turn_off: oled_power
      - switch.turn_off: pms_power
      - switch.turn_off: internal_heater
      - delay: 100ms
      - script.execute: smart_sleep

    # Enable PMS5003 if battery level is sufficient
  - id: maybe_enable_pms
    then:
      - lambda: |-
          float battery_v = id(batt_voltage).state;
          float solar_i = id(solar_current).state;

          if (battery_v > 3.6 || solar_i > 20.0) {
            ESP_LOGI("pms_control", "Battery OK → Powering PMS sensor");
            id(pms_power).turn_on();
          } else {
            ESP_LOGI("pms_control", "Low battery → PMS sensor off");
            id(pms_power).turn_off();
          }

  # Heater safety timeout
  - id: heater_timeout_guard
    mode: restart
    then:
      - delay: 10min
      - switch.turn_off: internal_heater

# Automatic heater activation based on internal temp

climate:
  - platform: thermostat
    name: "Enclosure Heater Control"
    id: enclosure_heater_control
    sensor: enclosure_temp
    humidity_sensor: ambient_humidity
    min_idle_time: 60s
    min_heating_off_time: 120s
    min_heating_run_time: 180s
    heat_deadband: 0.3°C
    heat_overrun: 1.5°C
    visual:
      min_temperature: -20
      max_temperature: 10
    default_preset: "Normal"
    on_boot_restore_from: memory
    preset:
      # Normal Heating Mode
      - name: "Normal"
        mode: heat
        default_target_temperature_low: 2.0
      # Economy Heating Mode
      - name: "Eco"
        mode: heat
        default_target_temperature_low: 0.5
      # Boost Heating Mode
      - name: "Boost"
        mode: heat
        default_target_temperature_low: 4.0
      # Disable Heating Mode
      - name: "Disable"
        mode: heat
        default_target_temperature_low: -20.0
    heat_action:
      - switch.turn_on: internal_heater
      - script.execute: heater_timeout_guard
    idle_action:
      - switch.turn_off: internal_heater

#   ─────────────────────────────── DISPLAY ─────────────────────────────

# Track display page
globals:
  - id: display_page
    type: int
    restore_value: no
    initial_value: "0"

# Display page turn interval
interval:
  - interval: 3s
    then:
      - lambda: |-
          id(display_page) = (id(display_page) + 1) % 2;

# OLED display fonts
font:
  - file: "fonts/Roboto-Regular.ttf"
    id: roboto
    size: 16

  - file: "fonts/arial.ttf"
    id: font_small
    size: 12

  - file: "fonts/arial.ttf"
    id: font_large
    size: 28
    glyphs: [" ", "A", "C", "E", "K", "L", "O", "W"]

# Display powered via GPIO7 through MOSFET
output:
  - platform: gpio
    pin: GPIO7
    id: oled_power

# Display activation button
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO9
      inverted: true
      ignore_strapping_warning: true
      mode:
        input: true
        pullup: true
    id: oled_activate_button
    name: "OLED Activate Button"
    on_press:
      - output.turn_on: oled_power
      - delay: 10s # Display timeout
      - output.turn_off: oled_power

# Display configuration
display:
  - platform: ssd1306_i2c
    model: "SH1107 128x128"
    address: 0x3C
    rotation: 0
    lambda: |-
      if (id(wake_hold_switch).state) {
        it.printf(32, 34, id(font_large), "WAKE");
        it.printf(32, 68, id(font_large), "LOCK");
        return;
      }

      if (id(display_page) == 0) {
        it.printf(0, 0, id(font_small), "Temp: %.1f°C", id(ambient_temp).state);
        it.printf(0, 14, id(font_small), "Hum:  %.0f%%", id(ambient_humidity).state);
        it.printf(0, 28, id(font_small), "IntTemp: %.1f°C", id(enclosure_temp).state);
        it.printf(0, 42, id(font_small), "Batt: %.0f%%", id(batt_percent).state);
        it.printf(0, 56, id(font_small), "Solar: %.1fW", id(solar_power).state);
      } else {
        it.printf(0, 0, id(font_small), "Light: %.0f", id(ambient_light).state);
        it.printf(0, 14, id(font_small), "Pressure: %.0f hPa", id(atmospheric_pressure).state);
        it.printf(0, 28, id(font_small), "Pond Temp: %.1f°C", id(pond_temp).state);
        it.printf(0, 42, id(font_small), "Water Depth: %.0fcm", id(pond_level).state);
      }
